---
layout: post
title:  "G6 源码阅读"
---

### 简介:

[G6](https://antv.alipay.com/zh-cn/g6/3.x/index.html) 官网的介绍如下:

```
G6 是一个简单、易用、完备的图可视化引擎，它在高定制能力的基础上，
提供了一系列设计优雅、便于使用的图可视化解决方案。
能帮助开发者搭建属于自己的图 图分析 应用或是 图编辑器 应用。
```

这是一个很难抽象的库，既要有足够的拓展性以满足各种定制化的业务需求，又要让开发者用起来简单。

G6 跟 [G2](https://github.com/antvis/g2) 一样依赖底层图表库 [G](https://github.com/antvis/g), [这里我写了一个 demo](https://codepen.io/dd1994/pen/ZEzQLWE), 用 G 的 API 做一个最简单的关系图, 有点繁琐，跟直接调用浏览器的 canvas API 画图差不多。G6 的工作就是在 G 之上再封装一层，让可视化更加容易。

G6 的代码用的是 `@babel/preset-env` 的语法, 没用 TypeScript, 所以看的有点难受，比如都用 Class 了但是没法用私有方法和私有属性，只能在名字前加个下划线 `_` 区分。

[官网上给出的类结构](https://www.yuque.com/antv/g6/sxoq6x#ec41b9b1)如下, 整个结构还是比较简单的，代码量也不大: ![image](https://cdn.nlark.com/yuque/__puml/82239a27f42191feab6aa6f7c7222e17.svg)


首先我们来理解一下G6 代码的主流程。用 G6 做图时，最基础的步骤是:

```js
const data = {
  nodes: [{
    id: 'node1',
    x: 100,
    y: 200
 },{
    id: 'node2',
    x: 300,
    y: 200
 }],
  edges: [{
    source: 'node1',
    target: 'node2'
 }]
};

const graph = new G6.Graph({
  container: 'mountNode',
  width: 500,
  height: 500
});
graph.data(data);
graph.render();
```

这里只有三个函数，我们先从 Graph 这个类的构造函数入手，再看 data 和 render 方法。

## 1. Graph 构造函数:

首先打开 `src/graph/graph.js` 文件，找到构造函数:

```js
  constructor(inputCfg) {
    super();
    this._cfg = Util.deepMix(this.getDefaultCfg(), inputCfg);    // merge graph configs
    this._init();
  }
```
`deepMix` 类似 `Object.assign`, 用来 merge 默认配置和 Graph 初始化时传入的配置，并且把所有配置都存到了 `this._cfg` 下，`set` 和 `get` 方法很简单，就是改变和获取 `this._cfg` 里的属性.。
然后再看调用的 `_init` 方法:

```js
  _init() {
    this._initCanvas();
    const eventController = new Controller.Event(this);
    const viewController = new Controller.View(this);
    const modeController = new Controller.Mode(this);
    const itemController = new Controller.Item(this);
    const stateController = new Controller.State(this);
    this.set({ eventController, viewController, modeController, itemController, stateController });
    this._initPlugins();
  }
```

1. 首先 `_initCanvas`
2. 分别实例化了 `Event`, `View`, `Mode`, `Item`, `State` 5 个类
3. 然后 `_initPlugins`。

### 1. 先看 `_initCanvas`:
```js
  _initCanvas() {
    let container = this.get('container');
    if (Util.isString(container)) {
      container = document.getElementById(container);
      this.set('container', container);
    }
    if (!container) {
      throw Error('invalid container');
    }
    const canvas = new G.Canvas({
      containerDOM: container,
      width: this.get('width'),
      height: this.get('height'),
      renderer: this.get('renderer'),
      pixelRatio: this.get('pixelRatio')
    });
    this.set('canvas', canvas);
    this._initGroups();
  }
```
先调用 `G.Canvas` 创建一块画布，然后保存到 `_cfg.canvas` 里，这里 `G.Canvas` 如何作图暂时不展开了，因为那要深入到 `G` 的源码，就是另外一个话题了。然后再来看 `this._initGroups`: 

```js
  _initGroups() {
    const canvas = this.get('canvas');
    const id = this.get('canvas').get('el').id;
    const group = canvas.addGroup({ id: id + '-root', className: Global.rootContainerClassName });
    if (this.get('groupByTypes')) {
      const edgeGroup = group.addGroup({ id: id + '-edge', className: Global.edgeContainerClassName });
      const nodeGroup = group.addGroup({ id: id + '-node', className: Global.nodeContainerClassName });
      this.set({ nodeGroup, edgeGroup });
    }
    this.set('group', group);
  }
```
这里是初始化 Group 配置, `Group` 是 [G 里面的一个概念](https://www.yuque.com/antv/g6/smhvyn#eacfb1bf)。
> 图形分组可以嵌套图形和分组

就是说 `Group` 下可以嵌套再 `addGroup`, 也可以 `addShape`。其实分组很好理解，比如关系图中的节点，有图形和文字 label, 但是我们把他们加到一个 Group 里，这样方便一起操作，比如拖动，删除等，同时，所有的节点也在一个分组，这样构成了嵌套结构， 其中， 子 group 是存在上一级的 children 数组中。可以在 debugger 中检查:
![image](https://si.geilicdn.com/img-6ba60000016c8e4f81d80a211580-unadjust_1110_1077.png)

以下面 <http://127.0.0.1:2046/demos/index.html#/image-node> 这个 demo为例：

![image](https://si.geilicdn.com/img-113b0000016c8e5229c20a211587-unadjust_659_537.png)

它的 Group 结构是:

![image](https://si.geilicdn.com/img-177e0000016c8e5c1b0c0a2166a4-unadjust_1520_1124.png)

### 2. 实例化 `Event`, `View`, `Mode`, `Item`, `State` 5 个类
这个先略过，后面再绕回来看。

### 3. `_initPlugins`
插件机制不影响主流程，先略过不看。

## 2. data 方法

```js
  data(data) {
    this.set('data', data);
  }
```
就是简单的把 data 存到 `this._cfg` 下。

## 3. render 方法

```js
   render() {
    const self = this;
    const data = this.get('data');
    if (!data) {
      throw new Error('data must be defined first');
    }
    this.clear();
    this.emit('beforerender');
    const autoPaint = this.get('autoPaint');
    this.setAutoPaint(false);
    Util.each(data.nodes, node => {
      self.add(NODE, node);
    });
    Util.each(data.edges, edge => {
      self.add(EDGE, edge);
    });
    if (self.get('fitView')) {
      self.get('viewController')._fitView();
    }
    self.paint();
    self.setAutoPaint(autoPaint);
    self.emit('afterrender');
  }
```
这段代码最核心的是遍历边和节点，然后调用 `add` 方法, 也就是`addItem` 方法:
```js
 addItem(type, model) {
    debugger
    return this.get('itemController').addItem(type, model);
 }
```
其中, `itemController` 是构造函数里 `_init` 实例化的，
打开 `src/graph/controller/item.js` 文件, 找到 addItem 方法:
```js
  addItem(type, model) {
    const graph = this.graph;
    const parent = graph.get(type + 'Group') || graph.get('group');
    const upperType = Util.upperFirst(type);
    let item;
    let styles = graph.get(type + 'Style') || {};
    const defaultModel = graph.get(CFG_PREFIX + upperType);
    const mapper = graph.get(type + MAPPER_SUFFIX);
    if (mapper) {
      const mappedModel = mapper(model);
      if (mappedModel.styles) {
        styles = mappedModel.styles;
        delete mappedModel.styles;
      }
      Util.each(mappedModel, (val, cfg) => {
        model[cfg] = val;
      });
    } else if (defaultModel) {
      // 很多布局会直接修改原数据模型，所以不能用 merge 的形式，逐个写入原 model 中
      Util.each(defaultModel, (val, cfg) => {
        if (!hasOwnProperty.call(model, cfg)) {
          if (Util.isObject(val)) {
            model[cfg] = Util.clone(val);
          } else {
            model[cfg] = defaultModel[cfg];
          }
        }
      });
    }
    graph.emit('beforeadditem', { type, model });
    if (type === EDGE) {
      let source = model.source;
      let target = model.target;
      if (source && Util.isString(source)) {
        source = graph.findById(source);
      }
      if (target && Util.isString(target)) {
        target = graph.findById(target);
      }
      if (!source || !target) {
        console.warn('The source or target node of edge ' + model.id + ' does not exist!');
        return;
      }
      debugger
      item = new Item[upperType]({
        model,
        source,
        target,
        styles,
        linkCenter: graph.get('linkCenter'),
        group: parent.addGroup()
      });
    } else {
      debugger
      item = new Item[upperType]({
        model,
        styles,
        group: parent.addGroup()
      });
    }
    graph.get(type + 's').push(item);
    graph.get('itemMap')[item.get('id')] = item;
    graph.autoPaint();
    graph.emit('afteradditem', { item, model });
    return item;
  }
```
